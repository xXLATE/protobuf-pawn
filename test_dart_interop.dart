 import 'dart:typed_data';
import 'test/test_dart/example.pb.dart';

void main() {
  print('=== Dart Protobuf Interoperability Test ===\n');
  
  // Test cases that should match Pawn output
  testSomeRPCRequest();
  testSomeRPCResponse();  
  testDonkey();
  
  print('=== All Dart tests completed ===\n');
}

void testSomeRPCRequest() {
  print('Testing SomeRPCRequest serialization...');
  
  // Create test data (same as in Pawn)
  var request = SomeRPCRequest()
    ..id = 12345
    ..name = 'TestUser';
  
  // Serialize to bytes
  var packedBytes = request.writeToBuffer();
  
  print('Original data: id=${request.id}, name=${request.name}');
  print('Packed size: ${packedBytes.length} bytes');
  
  // Print packed bytes in hex format (for comparison with Pawn)
  var hexBytes = packedBytes.map((b) => b.toRadixString(16).padLeft(2, '0').toUpperCase()).join(' ');
  print('Packed bytes: $hexBytes');
  
  // Deserialize from bytes
  var unpacked = SomeRPCRequest.fromBuffer(packedBytes);
  
  print('Unpacked data: id=${unpacked.id}, name=${unpacked.name}');
  
  // Verify data integrity
  if (request.id == unpacked.id && request.name == unpacked.name) {
    print('✓ SomeRPCRequest test PASSED\n');
  } else {
    print('✗ SomeRPCRequest test FAILED - data mismatch\n');
  }
}

void testSomeRPCResponse() {
  print('Testing SomeRPCResponse serialization...');
  
  // Create test data (same as in Pawn)
  var response = SomeRPCResponse()
    ..result = 'Operation completed successfully';
  
  // Serialize to bytes
  var packedBytes = response.writeToBuffer();
  
  print('Original data: result=${response.result}');
  print('Packed size: ${packedBytes.length} bytes');
  
  // Print packed bytes in hex format (for comparison with Pawn)
  var hexBytes = packedBytes.map((b) => b.toRadixString(16).padLeft(2, '0').toUpperCase()).join(' ');
  print('Packed bytes: $hexBytes');
  
  // Deserialize from bytes
  var unpacked = SomeRPCResponse.fromBuffer(packedBytes);
  
  print('Unpacked data: result=${unpacked.result}');
  
  // Verify data integrity
  if (response.result == unpacked.result) {
    print('✓ SomeRPCResponse test PASSED\n');
  } else {
    print('✗ SomeRPCResponse test FAILED - data mismatch\n');
  }
}

void testDonkey() {
  print('Testing Donkey serialization...');
  
  // Create test data (same as in Pawn)
  var donkey = Donkey()
    ..hi = 'Hello from Pawn!';
  
  // Serialize to bytes
  var packedBytes = donkey.writeToBuffer();
  
  print('Original data: hi=${donkey.hi}');
  print('Packed size: ${packedBytes.length} bytes');
  
  // Print packed bytes in hex format (for comparison with Pawn)
  var hexBytes = packedBytes.map((b) => b.toRadixString(16).padLeft(2, '0').toUpperCase()).join(' ');
  print('Packed bytes: $hexBytes');
  
  // Deserialize from bytes
  var unpacked = Donkey.fromBuffer(packedBytes);
  
  print('Unpacked data: hi=${unpacked.hi}');
  
  // Verify data integrity
  if (donkey.hi == unpacked.hi) {
    print('✓ Donkey test PASSED\n');
  } else {
    print('✗ Donkey test FAILED - data mismatch\n');
  }
}

// Test function to verify that Pawn-generated bytes can be read by Dart
void testPawnToDartInterop() {
  print('Testing Pawn to Dart interoperability...');
  
  // Example hex bytes that should come from Pawn (for SomeRPCRequest with id=12345, name="TestUser")
  // This is just an example - actual bytes would come from running Pawn code
  var pawnGeneratedHex = '08B9601212546573745573657I'; // Expected protobuf encoding
  
  try {
    // Convert hex string to bytes
    var bytes = hexStringToBytes(pawnGeneratedHex);
    
    // Try to deserialize with Dart
    var request = SomeRPCRequest.fromBuffer(bytes);
    
    print('Successfully decoded Pawn data:');
    print('  id: ${request.id}');
    print('  name: ${request.name}');
    print('✓ Pawn to Dart interop test PASSED\n');
    
  } catch (e) {
    print('✗ Pawn to Dart interop test FAILED: $e\n');
  }
}

// Utility function to convert hex string to bytes
Uint8List hexStringToBytes(String hexString) {
  var cleanHex = hexString.replaceAll(' ', '');
  var bytes = Uint8List(cleanHex.length ~/ 2);
  
  for (int i = 0; i < cleanHex.length; i += 2) {
    var hexByte = cleanHex.substring(i, i + 2);
    bytes[i ~/ 2] = int.parse(hexByte, radix: 16);
  }
  
  return bytes;
}